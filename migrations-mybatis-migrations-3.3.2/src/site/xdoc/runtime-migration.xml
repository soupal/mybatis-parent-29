<?xml version="1.0" encoding="UTF-8"?>
<!--

       Copyright 2010-2016 the original author or authors.

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.

-->
<document xmlns="http://maven.apache.org/XDOC/2.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

  <properties>
    <title>MyBatis Migrations | Runtime Schema Upgrade</title>
    <author email="mybatis-dev@googlegroups.com">The MyBatis Team</author>
  </properties>

  <body>

    <section name="Runtime Schema Upgrade">

      <p>
        Since 3.2.0, MyBatis Migrations supports runtime schema upgrade (a.k.a. in-app migration).
      </p>

      <p>
        If you distributed your application in binary form (e.g. WAR or JAR) and want to make some changes to the database schema after the initial release, that's where the Runtime Schema Upgrade helps.
      </p>

      <subsection name="Overview">

        <p>
          To use Runtime Schema Upgrade, you need to create Migration Scripts.<br />
          Migration scripts can be written as text files (.sql) or java classes that implements <code>MigrationScript</code> interface.
        </p>

        <p>
          Then during the startup process of your application, perform 'Up' operation by executing <code>UpOperation#operate()</code> method.<br />
          Assuming that your java migration scripts are in 'mycompany.migration.script' package and you can obtain <code>java.sql.DataSource</code> instance, the below is the minimum code to perform 'Up' operation.
        </p>

        <source><![CDATA[new UpOperation().operate(
  new DataSourceConnectionProvider(dataSource),
    new JavaMigrationLoader("mycompany.migration.script"), null, null);]]></source>

        <p>
          As the first migration script should be the one that creates the 'changelog' table, the initial release of your application may contain two or more migration scripts.<br />
          To upgrade the schema in the next version, just add new migration scripts to the package.
        </p>

      </subsection>

      <subsection name="Migration Script">

        <p>
          By default, MyBatis Migration supports two types of Migration Script: simple SQL script file (*.sql) and java migration script.
        </p>

        <p>
          You have already learned about the simple SQL script file (*.sql) that can be generated by the <code>migrate new</code> command in the former sections.
          As it is just a text file, it is easy to write or edit, but a little bit harder to use with Runtime Schema Upgrade because it needs to be accessible in the file system (i.e. JAR or WAR must be extracted on the runtime environment).
        </p>

        <p>
          A java migration script is a java class that implements <code>MigrationScript</code> interface (see below).
          It must be compiled, of course, but it can be placed anywhere in the classpath, so it may be a better choice for Runtime Schema Upgrade in most cases.
        </p>

        <source><![CDATA[
public interface MigrationScript {
  BigDecimal getId();
  String getDescription();
  String getUpScript();
  String getDownScript();
}]]></source>

        <p>
          <code>getId()</code> method should return a unique ID of the migration script. Newer script must return a larger number.<br />
          <code>getDescription()</code> method should return a short description of the script.<br />
          <code>getUpScript()</code> method should return the actual SQL statements upgrading the schema.<br />
          <code>getDownScript()</code> method should return SQL statements downgrading the schema, but it exists mainly for API consistency and would not be used in Runtime Schema Upgrade.
        </p>

        <p>
          Here is a typical implementation of the first migration script that creates the 'changelog' table:
        </p>

        <source><![CDATA[
package mycompany.migration.script

import java.math.BigDecimal;
import org.apache.ibatis.migration.MigrationScript;

public class V001_CreateChangelog implements MigrationScript {
  public BigDecimal getId() {
    return BigDecimal.valueOf(1L);
  }

  public String getDescription() {
    return "Create changelog";
  }

  public String getUpScript() {
    return "CREATE TABLE changelog ("
      + "ID NUMERIC(20,0) NOT NULL,"
      + "APPLIED_AT VARCHAR(25) NOT NULL,"
      + "DESCRIPTION VARCHAR(255) NOT NULL); "

      + "ALTER TABLE changelog "
      + "ADD CONSTRAINT PK_changelog "
      + "PRIMARY KEY (id);";
  }

  public String getDownScript() {
    return "DROP TABLE changelog;";
  }
}]]></source>

      </subsection>

      <subsection name="UpOperation#operate()">

        <p>
          As shown in the Overview section, Runtime Schema Upgrade is executed by calling the <code>operate()</code> method of an <code>UpOperation</code> instance.<br />
          The method takes four parameters.
        </p>

        <ul>
          <li><code>ConnectionProvider</code>: Required. Explained in the later section.</li>
          <li><code>MigrationLoader</code>: Required. Explained in the later section.</li>
          <li><code>DatabaseOperationOption</code>: Optional. If <code>null</code> is passed, the default values are used.</li>
          <li><code>PrintStream</code>: Optional. The result of the Up operation will be output to this stream.</li>
        </ul>

      </subsection>

      <subsection name="ConnectionProvider">

        <p>
          <code>ConnectionProvider</code> interface has only one method <code>getConnection()</code> which returns <code>java.sql.Connection</code> used by 'Up' operation.
        </p>

        <source><![CDATA[
public interface ConnectionProvider {
  Connection getConnection() throws SQLException;
}]]></source>

        <p>
          There are two built-in implementations: <code>DataSourceConnectionProvider</code> and <code>JdbcConnectionProvider</code>.
        </p>

        <p>
          You have already seen the example usage of <code>DataSourceConnectionProvider</code> in the Overview section.
          The constructor takes an instance of <code>java.sql.DataSource</code> as its only argument.
        </p>

        <p>
          <code>JdbcConnectionProvider</code> takes four constructor arguments: JDBC driver class, JDBC URL, username and password.<br />
          Using <code>JdbcConnectionProvider</code>, the example code in the Overview section can be rewritten as follows.
        </p>

        <source><![CDATA[new UpOperation().operate(
  new JdbcConnectionProvider("org.hsqldb.jdbcDriver", "jdbc:hsqldb:mem:mydb", "myname", "mypassword"),
    new JavaMigrationLoader("mycompany.migration.script"), null, null);]]></source>

      </subsection>

      <subsection name="MigrationLoader">

        <p>
          <code>MigrationLoader</code> abstracts where and how to load your migration scripts.<br />
          There are two built-in implementations: <code>FileMigrationLoader</code> and <code>JavaMigrationLoader</code>.
        </p>

        <p>
          <code>FileMigrationLoader</code> is used to load simple SQL scripts (*.sql).<br />
          Its constructor takes three arguments:
        </p>

        <source><![CDATA[FileMigrationLoader(File scriptsDir, String charset, Properties properties)]]></source>

        <ul>
          <li><code>scriptsDir</code> is the only required parameter and it indicates the directory containing the migration scripts. Note that the directory must exist in the file system of the runtime environment.</li>
          <li><code>charset</code> is the character set of the migration scripts.
          If <code>null</code> is passed, system's default charset is used.</li>
          <li><code>properties</code> is used for variable substitution when reading the migration scripts (e.g. ${changelog}).</li>
        </ul>

        <p>
          <code>JavaMigrationLoader</code> loads java classes which implement <code>MigrationScript</code> interface.<br />
          There are two constructors defined for <code>JavaMigrationLoader</code>
        </p>

        <source><![CDATA[JavaMigrationLoader(String... packageNames)

JavaMigrationLoader(ClassLoader classLoader, String... packageNames)]]></source>

        <ul>
          <li><code>packageNames</code> is the list of packages that contains migration scripts.
          Note that the migration scripts are ordered by their IDs.</li>
          <li><code>classLoader</code> is used to search the migration scripts and is optional.</li>
        </ul>

      </subsection>

    </section>

  </body>

</document>
